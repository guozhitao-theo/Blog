---
title: 从输入URL到页面展示发生了什么
date: 2022-03-02 22:25:04
tags: javascript基础
keywords: 浏览器
categories: 笔记
---
# 从输入URL到页面展示，这中间发生了什么？- 导航&渲染

## 前置知识-各个进程的主要职责

* 浏览器进程主要负责用户交互、子进程管理和文件存储等功能。
* 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
* 渲染进程的主要职责是把从网络下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所有运行在渲染进程里面的代码是不被信任的。所以Chrom 让渲染进程运行在安全沙箱里，就是为了保证系统的安全。

## 导航

### 1. 用户输入

用户在浏览器地址栏输入查询关键字时，地址栏判断输入的关键字是搜索内容还是请求的URL.

* 如果是搜索内容，地址栏使用浏览器默认搜索引擎，来合成新的带搜索关键字的URL。
* 如果判断输入内容符合URL规则，地址栏根据规则，合成为完整的URL。

当用户输入关键字并回车之后，当前页面可以执行一次[ beforeunload](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/beforeunload_event)事件，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。

### 2. URL请求过程

1. 浏览器进程通过进程间通信(IPC)把URL请求发送至网络进程。

2. 网络进程查找本地缓存是否缓存了该资源？

    * 如果有缓存，直接返回资源给浏览器进程。
    * 如果没有在缓存中找到资源，那么直接进入网络请求流程。

3. 网络请求流程如下：

    1. 进行DNS解析，获取服务器ip地址(默认端口是80/443)。

    2. 如果协议是HTTPS，还需要建立TLS连接。

    3. 利用IP地址和服务器建立TCP连接。

    4. 构建请求行、请求头等信息，把和该域名相关的Cookie等数据附加到请求头中。

    5. 向服务器发送构建的请求信息。

    6. 服务器收到请求信息后，根据请求信息生成响应数据（包括响应行、响应头、响应体等信息），并发给浏览器网络进程。

4. 网络进程接收响应头和响应信息，并解析响应内容。解析响应流程：

    1. 检查状态码，如果是301/302，则需要重定向，从响应头中Location字段合成完整的URL，[重新从URL请求过程的第2步执行。](#URL请求过程)
    2. 200响应处理:
    * 检查响应类型Content-Type，如果是`octet-stream` 字节流类型，则被判断为下载类型，请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程结束。
    * 如果是HTML（`text/html`）浏览器继续进行导航流程。


### 3. 准备渲染流程

1. 浏览器进程检查当前url是否和之前打开的渲染进程根域名相同，如果相同则服用原来的进程，如果不同，则开启新的渲染进程。
2. 提交文档，浏览器进程将网络进程收到的HTML数据交给渲染进程，流程如下：
    1. 当浏览器进程收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
    2. 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
    3. 等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程；
    4. 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。所以在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。
    5. 导航流程就“走”完了，这之后就要进入渲染阶段了。

## 渲染

### 1. 构建DOM树

为什么要构建DOM树呢？因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构-DOM树。

构建DOM树的输入内容是一个非常简单的HTML文件，然后经由HTML解析器解析，最终输出树状结构的DOM。



### 2. 样式计算（Recalculate Style）

1. 把CSS转换为浏览器能够理解的结构。

   CSS来源：

   	* 通过`link`引入外部CSS文件
   	* `<style>`标记内的CSS
   	* 元素的style属性内嵌的CSS

   浏览器无法理解这些纯文本的CSS样式，所以当渲染引擎收到CSS文本时候，会将CSS文本转换为浏览器可以理解的结构--**`styleSheets`**。

2. 转换样式表中的属性值，使其标准化

   CSS文本中有很多属性值，例如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值。（2em -> 32px; blue -> rgba(0,0,255); bold->700）

3. 计算出DOM树中每个几点的具体样式-CSS继承规则，层叠规则。

   CSS继承规则：CSS继承就是每个DOM节点都包含有父节点的样式。

   层叠规则：样式优先级、后面的样式覆盖前面的样式。


### 3. 布局阶段

​	有了DOM树和DOM树中元素的样式，但这还不足以显示页面，因为我们还不知道DOM元素的几何位置信息。计算DOM树中可见元素的几何位置的过程叫做布局。

1. 创建布局树

    * 遍历DOM树中的所有可见节点，并把这些节点添加到布局树中。
    * 而不可见的节点会被布局树忽略掉，如head标签下面的全部内容，以及属性包含`display: none`的元素

2. 布局计算

3. 分层：因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，或者使用 z-indexing做z轴排序等，为了更加方便的实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生层一棵对应的图层树(layer Tree)**。

   浏览器的页面实际上被分成了很多图层，这些图层叠加后合成最终页面。

   并不是布局树的每个及诶单都包含一个图层，如果一个节点没有对应的层，那么这个几点就从属父节点的图层。

   渲染引擎为节点创建新图层的条件：

    * 拥有层叠上下文属性的元素会被提升为单独的一层。
      [明确定位属性的元素、元素透明属性的元素、使用CSS滤镜的元素等都会被提升成单独的图层。](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)

    * 需要裁剪（clip）的地方也会被创建为图层
      设置为overflow等裁剪会单独创建一个层，出现滚动条的时候，滚动条也会被单独提升为单独的层。


4. 图层绘制：

   渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个带绘制列表。

5. 栅格化（raster）操作

    1. 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，**主线程会把该绘制列表提交(commit)给合成线程**。
    2. 为避免绘制出所有图层产生太大的开销，**合成线程会将图层分为图块**，这些图块的大小通常是256×256 或者 512×512。
    3. **合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**通常，**栅格化过程都会使用GPU来加速，渲染进程把生成图块的指令发送给GPU,然后在GPU中执行生成图块的位图，并保存在GPU的内存中，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化。**

6. 合成和显示

    1. 一旦所有的图块都被光栅化，合成线程就会生成一个绘制图块的命令--“DrawQuad”，然后将该命令提交给浏览器进程。
    2. 浏览器进程里面有一个叫`viz`的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面绘制到内存中，最后再将内存显示在屏幕上。

## 总结

完整的从URL到页面展示流程：

1. 判断输入是搜索关键字还是URL，是关键字则合成带关键字的URL使用默认搜索引擎搜索，不是则合成URL。
2.  浏览器进程将合成URL通过进程间通信(IPC)发送给网络进程。
3. 查找本地是否存在缓存，存在则拦截请求使用缓存资源，没有命中缓存则发送网络请求。
4. 进行DNS解析获取目标服务器的ip地址。
5. 利用ip地址和服务器建立tcp连接。
6. 构建请求头，请求行等信息，并把相关Cookie等信息添加到请求头。
7. 向服务器发送构建的请求信息。
8. 服务器响应给浏览器网络进程。
9. 网络进程检查状态码判断是否需要重定向。301，302要根据Location地址重新开始第3步。
10. 状态码200的时候还要判断Content-Type，若是字节流则请求被提交给下载管理器，导航结束。
11. 若Content-Type为html 则继续导航流程。
12. 浏览器进程检查当前当前URL是否存在已经存在的根域名相同的渲染进程，若存在则打开就渲染进程。不存在则开启新的渲染进程。
13. 浏览器进程收到网络进程的响应头数据之后，便向渲染进程发起“提交文档消息”。
14. 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
15. 等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程。
16. 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。所以在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。
17. 渲染进程将HTML内容转换为能够读懂的DOM树结构。
18. 渲染引擎将CSS样式表转化为浏览器可以理解的`styleSheets`、计算出DOM节点的样式。
19. 创建布局树，并计算元素的布局信息。
20. 对布局树进行分层，并生成分层树。
21. 为每个图层生成绘制列表，并将其提交到合并线程。
22. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
23. 合成线程发送绘制图块命令`DrawQuad`给浏览进程。
24. 浏览进程根据`DrawQuad`消息生成页面，并显示到显示器上。

