---
title: javascript基础
date: 2020-12-02 21:11:17
tags: javascript基础
keywords: 执行上下文
categories: 笔记
---
> [javascript 高级](https://www.bilibili.com/video/BV1Mz4y1Q79G?p=27) 笔记
# 执行上下文
## 执行上下文
1. 代码分类
   * 全局代码
   * 函数代码（局部）

2. 全局执行上下文

     * 在执行全局代码前将window确定为全局执行上下文
     * 对全局数据进行预处理   变量提升
       * var 定义的全局变量==> undefined，添加为window的属性。
       * function声明的全局函数==> 赋值（fun）, 添加为window的方法。 同样会提升
       * this ==> 赋值window

    * 开始执行全局代码

3. 函数执行上下文

     * 在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈里面）
     * 对局部数据进行预处理   函数提升
       * 形参变量 ==> 赋值（实参）==> 添加为执行上下文的属性
       * argument ==> 赋值(实参列表)， 添加为执行上下文的属性
       * var 定义的局部变量==> undefined, 添加为执行上下文的属性
       * function声明的函数 ==> 赋值（fun），添加为执行上下文的方法
       * this ==> 赋值（调用函数的对象） 

## 执行上下文栈
1. 在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象
2. 在全局执行上下文（window）确定后，将其添加到栈中（压栈）
3. 在函数执行上下文创建之后，将其添加到栈中（压栈）
4. 在当前函数执行完之后，将栈顶的对象移除（弹栈）
5. 当所有代码执行完之后，栈中只剩window

## 注意
 1. 先变量提升，再函数提升
 2. 初始化在所有变量提升之后

# 作用域与作用域链
## 作用域
1. 理解
   * 就是一块“地盘”，一个代码所在的区域。
   * 它是静态的（相对于全局上下文对象）， 在编写代码的时候就确定了

2. 分类
   * 全局作用域
   * 函数作用域
   * 没有块作用域（ES6有了）

3. 作用
   * 隔离变量，不同作用域下同名变量不会有冲突
## 作用域与执行上下文的区别
1. 区别1
   * 全局作用域外每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在调用时。
   * 全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建
   * 函数执行上下文环境是在调用函数的时候，函数体代码执行之前创建

2. 区别2
   * 作用域是静态的，只要函数定义好了就一直存在，且不会发生变化
   * 上下文的环境是动态的，调用函数时创建，函数调用结束时上下文环境就会自动释放

3. 联系
   * 上下文环境（对象）是从属所在的作用域中
   * 全局上下文环境 ==> 全局作用域
   * 函数上下文环境 ==> 对应的函数使用域  

## 作用域链
1. 理解

   * 多个上下级关系的作用域形成的链，他的方向是从下向上的（从内到外）
   * 查找变量的时候沿着作用域链来查找的

2. 查找一个变量的查找规则
   * 在当前作用域的执行上下文中查找对应的属性如果有直接返回，否则进入2
   * 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入3
   * 再次执行2的相同操作，直到全局作用域，如果还找不到就抛出找不到的异常
 # 闭包
1. 如何产生闭包？
   * 当一个嵌套的内部（子）的内部函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包
2. 闭包到底是什么？
   * 使用chrom调试查看
   * 理解一：闭包是嵌套的内部函数
   * 理解二：内部函数包含被引用变量（函数）的对象
   * 注意：闭包存在于嵌套的内部函数中

3. 产生闭包的条件

   * 函数嵌套
   * 内部i函数引用了外部函数的数据（变量/函数）
4. 注意：

   * 执行子函数定义就会产生闭包（不用调用子函数）
5. 常见的闭包
   1. 将函数作为另一个函数的返回
   2. 将函数作为实参作为另一个函数调用

## 闭包的作用
 1. 使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）
 2. 让函数外部可以操作（读写）到函数内部的数据（变量/函数）

### 问题
 1. 函数执行完后，函数内部声明的局部变量是否还存在？ 一般不存在，存在于闭包中的变量才可能存在。
 2. 在函数外部能直接访问函数内部的局部变量吗？不能，但是我们可以通过闭包让外部操作它。

## 闭包的生命周期
 1. 产生：在嵌套内部函数定义执行完成时就产生了（不是在调用）
 2. 死亡：在嵌套的内部函数成为垃圾对象时

## 闭包的应用
 1. 定义JS模块
      * 具有特定功能的JS文件
      * 将所有的数据和功能都封装在一个函数内部（私有的）
      * 只向外暴露一个包含n个方法的对象和函数
      * 模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能
## 闭包的缺点
   * 函数执行完毕之后，函数内部的局部变量没有释放，占用内存的时间变长。
   * 容易造成内存泄漏
**解决**
   * 能不用闭包就不用
   * 及时释放

## 内存溢出与内存泄漏
1. 内存溢出
    1. 一种程序运行出现的错误
    2. 当程序运行的内存超过了剩余的内存时，就抛出内存溢出的错误
2. 内存泄漏
    1. 占用的内存没有及时释放
    2. 内存泄漏积累多了就会导致内存溢出
    3. 常见的内存泄漏
         * 意外的全局变量
         * 没有及时清理的定时器或回调函数
         * 闭包

# 继承模式
 1. 方式1，原型链的继承
    1. 套路
         * 定义父类型构造函数
         * 给父类型的原型添加方法
         * 定义子类型的构造函数
         * 创建父类型的对象赋值给子类型的原型
         * 将子类原型的结构属性属性设置为子类型
         * 给子类型原型添加方法
         * 创建子类型的对象：可以调用父类型的方法
    2. 关键
         * 子类型的原型为父类型的一个实例对象

 2. 借用构造函数继承（假的）
    1. 套路
       1. 定义父类型构造函数
       2. 定义子类型构造函数
       3. 在子类型构造函数中间调用父类型构造函数

    2. 关键：
       1. 在子类型构造函数中通过call()调用父类型构造函数
3. 组合继承
   1. 原型链+借用构造函数的组合继承
      1. 利用原型链实现对父类型方法的继承
      2. 利用super()借用父类型构造函数初始化相同的属性

# 线程机制与事件机制
##  进程与线程
   **进程：**　程序的一次执行，它占有一片独有的内存空间。　可以通过windows任务管理器查看进程
   **线程：** 
   * 是进程内的一个独立执行单元
   * 是程序执行的一个完整流程
   * 是cpu的最小调度单位

   **相关知识：**
   * 应用程序必须运行在某个进程的某个线程上
   * 一个进程中至少有一个运行的线程： 主线程，进程启动之后自动创建
   * 一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的
   * 一个进程内的数据可以供其中的多个线程直接共享
   * 多个进程之间的数据不能直接进行共享的
   * 线程池（thread pool）: 保存多个线程对象的容器，实现线程对象的反复利用
   　　
  **相关问题：**
  * 何为多进程程与多线程
    * 多进程运行： 一个应用程序可以同时启动多个实例运行
    * 多线程： 在一个进程内，同时有多个线程运行
  * 比较单线程和多线程
      1. 多线程
         1. 优点：
            * 能有效提升cpu的利用率
         2. 缺点：
            * 创建多线程开销
            * 线程之间切换开销
            * 死锁与状态同步问题
      2. 单线程
         1. 优点：
            * 顺序编程简单易懂
         2. 缺点：
            * 效率低
## js 是单线程还是多线程
   * js是单线程运行
   * 但使用H5中的 Web Workers可以多线程运行
## 浏览器运行是单线程还是多线程？
   * 都是多线程运行的
## 浏览器是单进程还是多进程？
   * 有的是单进程的
     * firefox
     * 老版IE
   * 有的是多线程的
     * chrome
     * 新版IE
   * 如何查看浏览器是否是多进程运行呢？
     * 任务管理器 

## 浏览器内核
 支持浏览器运行的最核心的程序
 不同浏览器可能不一样
 * Chrome, Safari: webkit
 * firefox: Gecko
 * IE: Trident
 * 360,搜狗等国内浏览器： Trident + webkit
### 内核由很多模块组成
== 主线程 ==
 * js引擎模块： 负责js程序的编译和运行
 * Html、css文档解析模块： 负责页面文本的解析
 * DOM/CSS模块： 负责dom/css在内存中间的相关处理
 * 布局和渲染模块: 负责页面的布局效果的绘制（内存中的对象）
== 分线程 ==
 * 定时器模块：负责定时器的管理
 * DOM事件响应模块： 负责事件的管理
 * 网络请求模块： 负责ajax请求
## Web workers
1. H5 规范提供了js分线程实现，取名为Web Workers
2. 相关API
   1. Worker：构造函数，加载分线程执行的js文件
   2. Woker.prototype.onmessage: 用于接收另一个线程的回调函数
   3. Worker.prototype.postMessage: 向另一个线程发送消息
3. 不足
   1. Worker代码不能操作DOM(更新UI)
   2. 不能跨域加载JS
   3. 不是每个浏览器都支持这个新特性