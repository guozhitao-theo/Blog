---
title: V8工作原理
date: 2022-03-03 15:11:55
keywords: V8
categories: 笔记
---
# V8工作原理

## JavaScript内存机制

### JavaScript 是什么类型的语言

javaScript是一种若类型的、动态的语言。

* **弱类型**，意味着你不需要告诉JavaScript引擎这个或那个变量是什么数据类型，JavaScript引擎在运行代码的时候自己会计算出来。
* **动态**，意味着你可以使用同一个变量保存不同类型的数据。

### JavaScript的数据类型

| 类型      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| Boolean   | 只有true和false两个值                                        |
| Null      | 只有一个值null                                               |
| Undefined | 一个没有被赋值的变量会有个默认值undefinde，变量提升时的默认值也是undefined |
| Number    | 根据ECMAScript标准，JavaScript中只有一种数字类型：基于IEEE754标准的双精度64位二进制格式的值，（-263-1）到263-1 |
| BigInt    | javaScript中一个新的数字类型，可以用任意精度标识整数，使用BigInt，即使超出Number的安全整数范围限制，也可以安全地存储和操作。 |
| String    | 用于表示文本数据。不同于类C语言，JavaScript的字符串时不可更改的 |
| Symbol    | 符号类型时唯一的并且时不可修改的，通常用来作为Object的key.   |
| Object    | 在JavaScript里，对象可以被看作是一组属性的集合               |

* 使用typeof检测Null类型时，返回的是Object。
* Object类型特殊，是包含了key-value对的数据类型。
* 前七中数据类型称为原始类型，对象类型被称为引用类型。

### 内存空间

在javaScript的执行过程中，主要有三种类型内存空间，分别是**代码空间、栈空间、堆空间**。

#### 栈空间和堆空间

栈空间就是调用栈，用来存储执行上下文的。

当执行一段代码时，需要先编译，并创建执行上下文，然后按照顺序执行代码。

赋值的时候javaScript引擎判断右边的值是什么类型

* 如果是原属类型，直接将值保存在执行上下文中的变量环境，而执行上下文又被压入到栈中，所以变量的值存放在栈中。

* 如果是引用类型，javaScript引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个“堆”中的地址，然后在将该数据的地址写进变量的值。

  对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当JavaScript需要访问该数据的时候，通过栈中的引用地址来访问的。

#### 为什么要分成栈和堆两个存储空间呢

JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

通常情况下，**栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过分配内存和回收内存都会占用一定的时间。

**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。**

#### 闭包

1. 当JavaScript引擎执行到闭包函数的时候，首先会编译，并创建一个空执行上下文。
2. 在编译过程中，遇到内部函数setName，JavaScript引擎还要堆内部函数做一次快速的词法扫描，发现该内部函数引用了闭包函数中的变量，由于是内部函数引用了外部函数的变量，所以JavaScript引擎判断这是一个闭包，于是在堆空间创建一个`closure()`的对象（这是一个内部对象，JavaScript是无法访问的），用来保存变量。
3. 接着继续扫描到其他内部方法的时候，若是这个方法内部还引用了闭包函数的变量，于是JavaScript引擎又将该变量添加到“closure(foo)”对象中。这个时候堆中的“`closure()对象`”中就包含了变量。
4. 调用闭包内部函数的时候，创建的执行上下文的变量环境中就包含了`closure`

产生闭包的核心有两步：

 	1. 需要预扫描内部函数；
 	2. 把内部函数引用的外部变量保存到堆中。
